var tipuesearch = {"pages":[{"url":"./pages/about/","text":"2017Spring 機械設計工程系-協同產品設計實習課程 40423245學員 個人課程倉儲: https://github.com/40423245/2017springcd_hw 個人課程投影片: https://40423245.github.io/2017springcd_hw/ 個人課程網誌: https://40423245.github.io/2017springcd_hw/blog/","title":"About","tags":"misc"},{"url":"./2017spring-cd-W17.html","text":"各組員倉儲中的 Github 檔案推送 2. window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } from browser import document as doc from browser import html import math # 準備繪圖畫布 canvas = doc[\"fourbar\"] container1 = doc['container1'] ctx = canvas.getContext(\"2d\") #繪製第一隻腳 ctx.beginPath() ctx.moveTo(409.49,177.9) ctx.lineTo(452.92,202.68) ctx.lineTo(304.26,463.26) ctx.lineTo(260.83,438.48) ctx.fillStyle=\"blue\" ctx.fill() #繪製第二隻腳 ctx.beginPath() ctx.moveTo(368.85,169.62) ctx.lineTo(502.67,438.12) ctx.lineTo(457.92,460.42) ctx.lineTo(324.1,191.92) ctx.fillStyle=\"red\" ctx.fill() 程式碼 from browser import document as doc from browser import html import math # 準備繪圖畫布 canvas = doc[\"fourbar\"] container1 = doc['container1'] ctx = canvas.getContext(\"2d\") #繪製第一隻腳 ctx.beginPath() ctx.moveTo(409.49,177.9) ctx.lineTo(452.92,202.68) ctx.lineTo(304.26,463.26) ctx.lineTo(260.83,438.48) ctx.fillStyle=\"blue\" ctx.fill() #繪製第二隻腳 ctx.beginPath() ctx.moveTo(368.85,169.62) ctx.lineTo(502.67,438.12) ctx.lineTo(457.92,460.42) ctx.lineTo(324.1,191.92) ctx.fillStyle=\"red\" ctx.fill()","title":"2017/06/14 W17 上課筆記","tags":"Course"},{"url":"./2017spring-cd-W16.html","text":"練習如何遠端連結Fossil伺服器 老師第一節課介紹如何利用Xming連結Fossil伺服器 第二節讓我們去聆聽學長們的專題報告 第三四節的報告延至下週","title":"2017/06/07 W16 上課筆記","tags":"Course"},{"url":"./2017spring-cd-W15.html","text":"利用brython繪製正齒輪以及半尺型的正齒輪，接著利用submodule繪製齒輪組，並在Onshape中繪製再一遍齒輪組，並將過程紀錄。 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } 1. 請以 W15 練習為網誌標題, 800x600 為畫布大小, 在畫布正中央畫一個半徑為 250 畫素, 壓力角 20, 齒數為 36 齒的漸開線正齒輪輪廓. from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear'] ctx = canvas.getContext(\"2d\") x = (canvas.width)/2 y = (canvas.height)/2 r = 250 # 齒數 n = 36 # 壓力角 pa = 20 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") ctx.beginPath() ctx.fillStytle = \"#000000\" ctx.font = \"40px ScriptS\" ctx.fillText(\"40423245\",x-50,y) ctx.stroke() 2. 完成後, 請在正齒輪中央寫上自己的學號, 並建立第二個 800x600 的畫布, 請畫出只有上半齒形的漸開線正齒輪輪廓 , 且該齒輪廓下方水平線, 連接兩端齒根圓點交的直線以紅色繪製, 且在齒輪下方以藍色字元寫上自己的學號. from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx-rp, midy, midx+rp, midy) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(-9,10,+1): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear2'] ctx = canvas.getContext(\"2d\") x = (canvas.width)/2 y = (canvas.height)/2 r = 250 # 齒數 n = 36 # 壓力角 pa = 20 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") ctx.beginPath() ctx.fillStytle = \"#000000\" ctx.font = \"40px ScriptS\" ctx.fillText(\"40423245\",x-50,y) ctx.stroke() 3. 請各學員在各自 github 倉儲中的 data/py 目錄中, 編寫一個可以採圓心座標, 節圓半徑, 齒數, 壓力角與定位角度作為輸入的齒輪程式函式, 交由組長從各組員的 submodule 設定中呼叫導入, 以便在各分組的網頁中完成一個畫出所有組員協同繪圖的齒輪減速組圖, 且各齒輪正中心必須寫上組員學號, 各組按照學號大小排序, 分別由最右邊齒數 16 齒開始囓合, 依序增加 2 齒, 當排至平面四齒囓合後, 第五位組員則以垂直方向向下囓合兩個齒輪後, 轉由右至左水平排列, 直至所有組員均各提供一個協同囓合用的齒輪為止. # 導入 browser 模組中的 document, 並設為 doc 變數 from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) # 準備在 id=\"gear3\" 的 canvas 中繪圖 canvas = doc[\"gear3\"] ctx = canvas.getContext(\"2d\") # 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角 # 壓力角 pa 單位為角度 pa = 20 # 第1齒輪齒數 n_g1 = 16 # 第2齒輪齒數 n_g2 = 18 # 第3齒輪齒數 n_g3 = 20 # 第4齒輪齒數 n_g4 = 22 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 m = (0.8*canvas.width)/(n_g1+n_g2+n_g3+n_g4) # 根據模數 m, 計算各齒輪的節圓半徑 rp_g1 = m*n_g1/2 rp_g2 = m*n_g2/2 rp_g3 = m*n_g3/2 rp_g4 = m*n_g4/2 #單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") # 開始繪製囓合齒輪輪廓 # 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離 x_g1 = canvas.width*0.1+rp_g1 # y 方向繪圖區域上方預留 canvas.height 的 20% y_g1 = canvas.height*0.2+rp_g1 # 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同 x_g2 = x_g1 + rp_g1 + rp_g2 y_g2 = y_g1 # 第3齒輪的圓心座標 x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3 y_g3 = y_g1 # 第4齒輪的圓心座標 x_g4 = x_g1 + rp_g1 + 2*rp_g2 + 2*rp_g3+rp_g4 y_g4 = y_g1 # 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2 # 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖 ctx.save() # translate to the origin of second gear ctx.translate(x_g1, y_g1) # rotate to engage ctx.rotate(math.pi/2) # put it back ctx.translate(-x_g1, -y_g1) # 繪製第一個齒輪輪廓 Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, \"blue\") ctx.restore() ctx.beginPath() ctx.fillStytle = \"#0000ff\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423222\",x_g1-30,y_g1) ctx.stroke() # 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g2, y_g2) # rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g2) # put it back ctx.translate(-x_g2, -y_g2) Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, \"black\") ctx.restore() ctx.beginPath() ctx.fillStytle = \"#000000\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423228\",x_g2-30,y_g2) ctx.stroke() # 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g3, y_g3) # rotate to engage # math.pi+math.pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度 # 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快 # 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度 # -math.pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合 # (math.pi+math.pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, # 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, # 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3 ctx.rotate(-math.pi/2-math.pi/n_g3+(math.pi+math.pi/n_g2)*n_g2/n_g3) # put it back ctx.translate(-x_g3, -y_g3) Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, \"red\") ctx.restore() ctx.beginPath() ctx.fillStytle = \"#ff0000\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423245\",x_g3-30,y_g3) ctx.stroke() # 將第4齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第3齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g4, y_g4) # rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g4+(math.pi+math.pi/n_g2)*n_g2/n_g3+(math.pi+math.pi/n_g3)*n_g3/n_g4) # put it back ctx.translate(-x_g4, -y_g4) Spur(ctx).Gear(x_g4, y_g4, rp_g4, n_g4, pa, \"green\") ctx.restore() ctx.beginPath() ctx.fillStytle = \"#008000\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423248\",x_g4-30,y_g4) ctx.stroke() 4. 請依照上述規劃, 在 Onshape 完成相同齒輪組的囓合協同繪圖. 齒輪組連結： 齒輪組 5. 各組員與組員請同時用 Youtube 與 vimeo, 紀錄上述各階段程式編寫與繪圖配置的 mp4 影片檔案, 標題為\"協同產品設計實習第十五週練習\" 在網誌完成齒輪組的囓合協同繪圖 40423245機械設計工程系 - 協同產品設計實習課程W15練習-在 網誌完成齒輪組的囓合協同繪圖 from 40423245 on Vimeo . 在 Onshape 完成相同齒輪組的囓合協同繪圖 40423245機械設計工程系 - 協同產品設計實習課程W15練習-在 Onshape 完成相同齒輪組的囓合協同繪圖 from 40423245 on Vimeo .","title":"協同產品設計實習第十五週練習","tags":"Course"},{"url":"./Strandbeest-2.html","text":"在Onshape中繪製蝸桿蝸輪 先繪製出蝸桿的草圖 接著迴轉擠出並繪製出螺旋線，高為24、Pitch為6 繪製出蝸桿的齒型 掃略擠出，在桿子的另一邊也是同樣的步驟 接著繪製蝸輪草圖，擠出22.7並倒角2 接著繪製迴轉切割草圖，並迴轉切割 接著繪製出蝸輪的螺旋線，旋轉尺寸為0.25、Pitch為6 接著繪製出蝸輪齒型草圖，並掃掠切割，蝸輪另一邊也是相同步驟 接著環形陣列44個 接著繪製出基座 接著即可到組合件匯入蝸桿蝸輪，利用轉動結合配合蝸桿蝸輪，然後利用齒輪指令限制其關係後，即可製作動畫 40423245機械設計工程系 - 協同產品設計實習課程W14-在Onshape中繪製蝸桿蝸輪 from 40423245 on Vimeo .","title":"2017/05/28 期末行走機構筆記-2","tags":"Course"},{"url":"./2017spring-cd-W14.html","text":"利用虛擬主機架設Ubuntu Server 16.04.2 由於沒有實體電腦，因此選擇虛擬主機來練習 啟動掛載好Ubuntu Server後，即可啟動虛擬電腦，一開始會選擇語言，選擇『English』 開始安裝，選擇『Install Ubuntu Server』 選擇安裝過程的語言，選擇『English』，接著選『United States』 接著會偵測鍵盤排列方式，選『No』，接著選擇鍵盤的配置，也都是選擇『English』 接著設定系統的主機名稱 接著設定使用者完整名稱 設定使用者帳號 設定使用者密碼 設置完後系統會問你密碼要設置得如此簡單嗎，選擇『Yes』 確認時區『Asia / Taipei』是否正確 選擇『Guided - use entire disk and set up LVM 選擇磁碟 是否寫入變更到磁碟，選擇『Yes』 設定分割區的空間容量 確認磁碟配置無誤，選擇『Yes』 設定 HTTP proxy，這裡不填寫 是否自動更新系統，選擇『No automatic updates』 是否要安裝其他軟體，選擇『OpenSSH server』;接著安裝 GRUB 開機選單 接著選擇不加密，安裝即完畢，電腦會退出光碟，接著即可登入server 40423245機械設計工程系 - 協同產品設計實習課程W14-利用虛擬主機架設Ubuntu Server 16.04.2 from 40423245 on Vimeo .","title":"2017/05/24 W14 上課筆記","tags":"Course"},{"url":"./2017spring-cd-W13.html","text":"在Onshape中繪製行走機構所需零件，並組立各個零件 先在Part Studio中設定好下列參數 接著繪製各零件草圖並導入參數 設定擠出參數為 3，並將零件擠出 接著設定軸的半徑參數為 2 並繪製草圖，接著擠出軸，尺寸分別為 厚度X2、厚度X3、厚度X6及厚度X15 接著到組合件組立行走機構，利用旋轉指令及圓柱指令結合各個零件，另用銷接指令加入軸 製作動畫時只能使兩隻腳同時作動，假如要使四隻腳同時作動，可使用群組指令將兩邊的作動軸設為一個群組 零件連結 ： Strandbeest 40423245機械設計工程系 - 協同產品設計實習課程W13-利用Onshape繪製行走機構所需零件 from 40423245 on Vimeo . 40423245機械設計工程系 - 協同產品設計實習課程W13-在Onshape上組立行走機構 from 40423245 on Vimeo . 40423245機械設計工程系 - 協同產品設計實習課程W13-在Onshape上模擬行走機構動畫 from 40423245 on Vimeo .","title":"2017/05/17 W13 上課筆記","tags":"Course"},{"url":"./2017spring-cd-W12.html","text":"在Onshape上繪製漸開線齒輪以及利用參數繪製齒輪 給定模數、齒數及壓力角後，繪製出節圓、齒頂圓、齒根圓及基圓 接著從基圓上拉出漸開線，接著繪製到齒根的垂直線，並對稱草圖，即可擠出齒型 接著即可加入參數繪製齒輪，可到老師網誌參考程式碼，亦可搜尋spur的FeatureScript 以下為對應的 FeatureScript 正齒輪輪廓繪圖程式碼: FeatureScript 581; import(path : \"onshape/std/geometry.fs\", version : \"581.0\"); annotation { \"Feature Type Name\" : \"Spur2\" } export const spur = defineFeature(function(context is Context, id is Id, definition is map) precondition { // 正齒輪齒數, 由使用者輸入, 型別為整數 annotation { \"Name\" : \"Number of Gear Tooth\" } isInteger(definition.n, POSITIVE_COUNT_BOUNDS); // 正齒輪模數, 由使用者輸入, 型別為長度, 為內建尺寸單位 annotation { \"Name\" : \"Module\" } isLength(definition.module, LENGTH_BOUNDS); // 正齒輪壓力角, 由使用者輸入, 型別為角度, 為內建角度單位 annotation { \"Name\" : \"Pressure Angle\" } isAngle(definition.pa, ANGLE_360_BOUNDS); // 正齒輪圓心座標點, 由使用者選擇 annotation { \"Name\" : \"Select a point\", \"Filter\" : EntityType.VERTEX, \"MaxNumberOfPicks\" : 1 } definition.point is Query; } { // Precondition 中的查詢, 需要 evalue 才能傳回對應的 entity var location = evaluateQuery(context, definition.point)[0]; // location 變數為點座標對應的 entity, 必須透過 evVetexPoint 的評量才能傳回對應的點座標 var center3D = evVertexPoint(context, { \"vertex\" : location }); // 作圖平面利用 evOwnerSketch 評量, 與 location entity 同一個平面 var sketchPlane = evOwnerSketchPlane(context, { \"entity\" : location }); // 作圖畫 const gearSketch = newSketchOnPlane(context, id + \"gearSketch\", { \"sketchPlane\" : sketchPlane }); // 利用 worldToPlane, 將 center3D 轉換為 sketchPlane 上的平面點座標 const center2D = worldToPlane(sketchPlane, center3D); //print(center2D); // 漸開線近似點數 var imax = 5; // 使用者所選的齒輪圓心 x 座標 var midx = center2D[0]; // 使用者所選的齒輪圓心 y 座標 var midy = center2D[1]; // 齒數 var n = definition.n; // 模數 var m = definition.module; // 壓力角, 單位為角度 var pa = definition.pa; // 齒輪的節圓半徑 var rp = m*n/2; skLineSegment(gearSketch, \"line\", { \"start\" : vector(midx,midy), \"end\" : vector(midx,midy+rp) }); // 齒根 var d = 2.5*rp/n; // 齒頂圓半徑 var ra = rp + m; // 基圓半徑 var rb = rp*cos(pa); //print(rb); // 齒根圓半徑 var rd = rp - d; // 分段後齒頂與齒根半徑差增量 var dr = 0*meter; // 若 rb > rd 時從基圓開始繪製漸開線, 但是若 rd > rb, 則漸開線從 rd 畫到齒頂圓 if (rd > rb) { // 半徑差的分段, 由齒根圓到齒頂圓 dr = (ra-rd)/imax; } else { // 半徑差的分段, 由基圓到齒頂圓 dr = (ra-rb)/imax; } // PI 為實數值沒有單位, tan(pa)也沒有單位, pa 已經設定單位為 degree, 這裡為了與 radian 運算 // 系統會自動轉為 radian var rot = PI/(2*n)*radian; //print(sigma); // 分別用來設定 entity id 用的增量變數 var nameId = 1; var nameId2 = 1; var r = 0*meter; // theta 為浮點數字 var theta = 0; var inv = 0*radian; var inc = 0*radian; // 當 r=rp 時 ,計算 inv_rp 用來旋轉漸開線用 // theta 為沒有單位的實數 theta = sqrt((rp*rp)/(rb*rb)-1); // atan(theta) 為 radian var inv_rp = theta*radian-atan(theta); // 漸開線上點的 x 座標 var xpt = 0*meter; // 漸開線上點的 y 座標 var ypt = 0*meter; // 左側漸開線第1點座標 left first x and y var lfx = 0*meter; var lfy = 0*meter; // 右側漸開線第1點座標 right first x and y var rfx = 0*meter; var rfy = 0*meter; // 左側齒根圓上點座標 left x of dedendum point var lxd = 0*meter; var lyd = 0*meter; // 右側齒根圓上點座標 right x of dedendum point var rxd = 0*meter; var ryd = 0*meter; // 左側齒根圓上點座標 right x of dedendum point (advanced) var lxd_ad = 0*meter; var lyd_ad = 0*meter; var inc_ad = 0*radian; for (var j=0;j<n;j+=1) { // 當 j 增量時, 按照齒數輪廓繞行旋轉增量角度 inc = (2.*j*PI/n)*radian; inc_ad = (2.*(j+1)*PI/n)*radian; if (rd>rb) { // 當齒根半徑因為齒數增多後大於基圓半徑時, 漸開線從齒根圓長起 theta = sqrt((rd*rd)/(rb*rb)-1.); inv = theta*radian-atan(theta); // 左側漸開線第1點座標 // 左側輪廓線配合逆時針旋轉 inc 角度 lfx = midx+rd*sin(inv-rot-inv_rp+inc); lfy = midy+rd*cos(inv-rot-inv_rp+inc); lxd = lfx; lyd = lfy; lxd_ad = midx+rd*sin(inv-rot-inv_rp+inc_ad); lyd_ad = midy+rd*cos(inv-rot-inv_rp+inc_ad); // 右側漸開線第1點座標 // 右側輪廓線配合順時針旋轉 inc 角度 rfx = midx-rd*sin(inv-rot-inv_rp-inc); rfy = midy+rd*cos(inv-rot-inv_rp-inc); rxd = rfx; ryd = rfy; // 齒根圓上的直線 on dedendum points skLineSegment(gearSketch, \"line_dd\" ~ nameId, { \"start\" : vector(rxd,ryd), \"end\" : vector((lxd_ad),(lyd_ad)) }); } else { // 當基圓半徑大於齒根圓時, 漸開線從基圓長起 theta = sqrt((rb*rb)/(rb*rb)-1.); inv = theta*radian-atan(theta); // 左側漸開線第1點座標 lfx = midx+rb*sin(inv-rot-inv_rp+inc); lfy = midy+rb*cos(inv-rot-inv_rp+inc); lxd = midx+rd*sin(inv-rot-inv_rp+inc); lyd = midy+rd*cos(inv-rot-inv_rp+inc); lxd_ad = midx+rd*sin(inv-rot-inv_rp+inc_ad); lyd_ad = midy+rd*cos(inv-rot-inv_rp+inc_ad); // 從基圓點到齒根圓點, 畫直線 left from base point to dedendum point skLineSegment(gearSketch, \"line_lbd\" ~ nameId, { \"start\" : vector(lfx,lfy), \"end\" : vector((lxd),(lyd)) }); // 右側漸開線第1點座標 rfx = midx-rb*sin(inv-rot-inv_rp-inc); rfy = midy+rb*cos(inv-rot-inv_rp-inc); rxd = midx-rd*sin(inv-rot-inv_rp-inc); ryd = midy+rd*cos(inv-rot-inv_rp-inc); // 從基圓點到齒根圓點, 畫直線 right from base point to dedendum point skLineSegment(gearSketch, \"line_rbd\" ~ nameId, { \"start\" : vector(rfx,rfy), \"end\" : vector((rxd),(ryd)) }); // 齒根圓上的直線 on dedendum points skLineSegment(gearSketch, \"line_dd\" ~ nameId, { \"start\" : vector(rxd,ryd), \"end\" : vector((lxd_ad),(lyd_ad)) }); } for (var i=1; i<imax+1; i+= 1) { // 先處理中線左側的漸開線 // 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if (rd>rb) { r = rd+i*dr; } else { r = rb+i*dr; } theta = sqrt((r*r)/(rb*rb)-1); var inv = theta*radian-atan(theta); // 漸開線上的點座標 xpt = midx+r*sin(inv-rot-inv_rp+inc); ypt = midy+r*cos(inv-rot-inv_rp+inc); // lxd, lyd 為漸開線上的繪線起點座標 skLineSegment(gearSketch, \"lineb\" ~ nameId, { \"start\" : vector(lfx,lfy), \"end\" : vector((xpt),(ypt)) }); // 更新漸開線點座標 lfx = xpt; lfy = ypt; nameId += 1; } // 紀錄左側漸開線的最後一點, 也就是齒頂圓上的點座標 var lastlx = xpt; var lastly = ypt; // another side for (var i=1; i<imax+1; i+= 1) { if (rd>rb) { r = rd+i*dr; } else { r = rb+i*dr; } theta = sqrt((r*r)/(rb*rb)-1); var inv = theta*radian-atan(theta); // 漸開線上的點座標 xpt = midx-r*sin(inv-rot-inv_rp-inc); ypt = midy+r*cos(inv-rot-inv_rp-inc); // rxd, ryd 為漸開線上的繪線起點座標 skLineSegment(gearSketch, \"linec\" ~ nameId, { \"start\" : vector(rfx,rfy), \"end\" : vector((xpt),(ypt)) }); // 更新漸開線點座標 rfx = xpt; rfy = ypt; nameId += 1; } var lastrx = xpt; var lastry = ypt; // 齒頂連線 skLineSegment(gearSketch, \"lined\" ~ nameId2, { \"start\" : vector(lastlx,lastly), \"end\" : vector(lastrx,lastry) }); nameId2 += 1; } skSolve(gearSketch); }); 注意事項 1.當齒根半徑因為齒數增多後大於基圓半徑時, 漸開線從齒根圓長起 2.當基圓半徑大於齒根圓時, 漸開線從基圓長起 零件連結 ： Onshape齒輪 練習影片 40423245機械設計工程系 - 協同產品設計實習課程W12-在Onshape上繪製漸開線齒輪 from 40423245 on Vimeo . 40423245機械設計工程系 - 協同產品設計實習課程W12-利用參數繪製齒輪 from 40423245 on Vimeo . 參考資料 Onshape Featurescript Spur Gear 輪廓繪圖 Gear Drawing with Bézier Curves","title":"2017/05/10 W12 上課筆記","tags":"Course"},{"url":"./2017spring-cd-W11.html","text":"利用漸開線原理, 以 Brython 繪製單一正齒輪廓 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear'] ctx = canvas.getContext(\"2d\") x = (canvas.width)/2 y = (canvas.height)/2 r = 0.8*(canvas.height/2) # 齒數 n = 53 # 壓力角 pa = 20 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") 單一正齒輪程式碼 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear'] ctx = canvas.getContext(\"2d\") x = (canvas.width)/2 y = (canvas.height)/2 r = 0.8*(canvas.height/2) # 齒數 n = 53 # 壓力角 pa = 20 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") 注意事項 1.當齒根半徑因為齒數增多後大於基圓半徑時, 漸開線從齒根圓長起 2.當基圓半徑大於齒根圓時, 漸開線從基圓長起 # 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容 from browser import document as doc # 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換 from browser import window import math # 主要用來取得畫布大小 canvas = doc[\"cango_gear\"] # 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx #ctx = canvas.getContext(\"2d\") cango = window.Cango.new # 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換 shapedefs = window.shapeDefs # 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形 # in CangoAnimation.js #interpolate1 = window.interpolate # Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件 cobj = window.Cobj.new creategeartooth = window.createGearTooth.new # 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id=\"cango_gear\" 的 canvas 上 cgo = cango(\"cango_gear\") ###################################### # 畫正齒輪輪廓 ##################################### # n 為齒數 n = 17 # pa 為壓力角 pa = 25 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth m = 0.8*canvas.width/n # pr 為節圓半徑 pr = n*m/2 # gear Pitch radius # generate gear data = creategeartooth(m, n, pa) # Brython 程式中的 print 會將資料印在 Browser 的 console 區 #print(data) gearTooth = cobj(data, \"SHAPE\", { \"fillColor\":\"#ddd0dd\", \"border\": True, \"strokeColor\": \"#606060\" }) gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中 gear = gearTooth.dup() # gear 為單一齒的輪廓資料 #cgo.render(gearTooth) # 利用單齒輪廓旋轉, 產生整個正齒輪外形 for i in range(1, n): # 將 gearTooth 中的資料複製到 newTooth newTooth = gearTooth.dup() # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear newTooth.rotate(360*i/n) # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號 gear.appendPath(newTooth, True) # trim move command = True # 建立軸孔 # add axle hole, hr 為 hole radius hr = 0.6*pr # diameter of gear shaft shaft = cobj(shapedefs.circle(hr), \"PATH\") shaft.revWinding() gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path cx = canvas.width/2 cy = canvas.height/2 gear.translate(cx, cy) # render 繪出靜態正齒輪輪廓 cgo.render(gear) 設法處理兩種正齒輪嚙合的協同繪圖 (17t-11t-13t): # 導入 browser 模組中的 document, 並設為 doc 變數 from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) # 準備在 id=\"gear3\" 的 canvas 中繪圖 canvas = doc[\"gear3\"] ctx = canvas.getContext(\"2d\") # 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角 # 壓力角 pa 單位為角度 pa = 20 # 第1齒輪齒數 n_g1 = 17 # 第2齒輪齒數 n_g2 = 11 # 第3齒輪齒數 n_g3 = 13 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 m = (0.8*canvas.width)/(n_g1+n_g2+n_g3) # 根據模數 m, 計算各齒輪的節圓半徑 rp_g1 = m*n_g1/2 rp_g2 = m*n_g2/2 rp_g3 = m*n_g3/2 #單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") # 開始繪製囓合齒輪輪廓 # 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離 x_g1 = canvas.width*0.1+rp_g1 # y 方向繪圖區域上方預留 canvas.height 的 20% y_g1 = canvas.height*0.2+rp_g1 # 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同 x_g2 = x_g1 + rp_g1 + rp_g2 y_g2 = y_g1 # 第3齒輪的圓心座標 x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3 y_g3 = y_g1 # 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2 # 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖 ctx.save() # translate to the origin of second gear ctx.translate(x_g1, y_g1) # rotate to engage ctx.rotate(math.pi/2) # put it back ctx.translate(-x_g1, -y_g1) # 繪製第一個齒輪輪廓 Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, \"blue\") ctx.restore() # 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g2, y_g2) # rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g2) # put it back ctx.translate(-x_g2, -y_g2) Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, \"black\") ctx.restore() # 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g3, y_g3) # rotate to engage # math.pi+math.pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度 # 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快 # 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度 # -math.pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合 # (math.pi+math.pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, # 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, # 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3 ctx.rotate(-math.pi/2-math.pi/n_g3+(math.pi+math.pi/n_g2)*n_g2/n_g3) # put it back ctx.translate(-x_g3, -y_g3) Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, \"red\") ctx.restore() 齒輪程式碼 # 導入 browser 模組中的 document, 並設為 doc 變數 from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) # 準備在 id=\"gear3\" 的 canvas 中繪圖 canvas = doc[\"gear3\"] ctx = canvas.getContext(\"2d\") # 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角 # 壓力角 pa 單位為角度 pa = 20 # 第1齒輪齒數 n_g1 = 17 # 第2齒輪齒數 n_g2 = 11 # 第3齒輪齒數 n_g3 = 13 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 m = (0.8*canvas.width)/(n_g1+n_g2+n_g3) # 根據模數 m, 計算各齒輪的節圓半徑 rp_g1 = m*n_g1/2 rp_g2 = m*n_g2/2 rp_g3 = m*n_g3/2 #單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") # 開始繪製囓合齒輪輪廓 # 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離 x_g1 = canvas.width*0.1+rp_g1 # y 方向繪圖區域上方預留 canvas.height 的 20% y_g1 = canvas.height*0.2+rp_g1 # 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同 x_g2 = x_g1 + rp_g1 + rp_g2 y_g2 = y_g1 # 第3齒輪的圓心座標 x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3 y_g3 = y_g1 # 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2 # 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖 ctx.save() # translate to the origin of second gear ctx.translate(x_g1, y_g1) # rotate to engage ctx.rotate(math.pi/2) # put it back ctx.translate(-x_g1, -y_g1) # 繪製第一個齒輪輪廓 Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, \"blue\") ctx.restore() # 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g2, y_g2) # rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g2) # put it back ctx.translate(-x_g2, -y_g2) Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, \"black\") ctx.restore() # 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g3, y_g3) # rotate to engage # math.pi+math.pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度 # 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快 # 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度 # -math.pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合 # (math.pi+math.pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, # 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, # 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3 ctx.rotate(-math.pi/2-math.pi/n_g3+(math.pi+math.pi/n_g2)*n_g2/n_g3) # put it back ctx.translate(-x_g3, -y_g3) Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, \"red\") ctx.restore() 注意事項 1.第1齒輪順時鐘轉 90 度 2.將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合 3.將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合","title":"2017/05/03 W11 上課筆記","tags":"Course"},{"url":"./2017spring-cd-W10.html","text":"將期中考週繪製的四連桿匯入V-rep 模擬 1.先將Onshape所繪製好的零件匯出成stl檔，接著匯入V-rap裡，並將各零件分解開來。 2.接著加入旋轉軸，與定位軸的位置重合，並將定位軸隱藏。 3.最後只要移好各零件與旋轉軸相對位置，即可加入馬達，將各零件實體化，就可以開始模擬了。 影片 40423245機械設計工程系 - 協同產品設計實習課程W10-將期中考所繪製的Fourbar Walker匯入V-rep並使其作動 from 40423245 on Vimeo .","title":"2017/04/26 W10 上課筆記","tags":"Course"},{"url":"./solve Leo editor problem.html","text":"解決在按下 start 之後會出現 cp950 及 Leo editor 無法開啟的問題 1.事發問題 由於利用 start 無法將 Leo 開啟，因此利用 SciTE 開啟 Leo，但出現 cp950 的畫面。 這是因為程式在讀取Leo時，讀取到了中文字，因此出現編碼問題。 2.事發原因 為了複製、保存檔案、對照檔案...時，將clone下來的倉儲複製到具有中文字檔名的資料夾裡，這樣在讀取此資料夾裡的Leo檔案時，即會發生編碼問題。 3.解決辦法 因為是在讀取位於data\\home.leo.leoRecentFiles.txt的檔案時發生問題 因此只要編輯此檔案並將具有中文字的那行刪掉即可，跟自己的倉儲資料無關 4.心得 要在電腦上使用中文字是一件麻煩又困難的事情，而且容易發生問題，因此學好英文是一件必要的事情。 5.操作影片 40423245機械設計工程系 - 協同產品設計實習課程W10-解決關於Leo顯示的cp950問題 from 40423245 on Vimeo .","title":"2017/04/20 解決Leo編輯器的問題","tags":"Course"},{"url":"./2017spring-cd-W9.html","text":"期中協同查驗與自評 (二) 四連桿機構協同 Trace Point 查驗 (1)利用solvespace進行點路徑的分析 (2)用Excel進行點的分析 (3)利用程式繪製路徑 window.onload=function(){ brython(1); } from browser import document as doc from browser import html import math # 準備繪圖畫布 canvas = doc[\"fourbar\"] container1 = doc['container1'] ctx = canvas.getContext(\"2d\") fourbar_data = open(\"./../data/image W9/fourbar 40.csv\").read() fourbar_list = fourbar_data.splitlines() #container1 <= fourbar_list[0] # 以下可以利用 ctx 物件進行畫圖 # 先畫一條直線 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 利用 transform 將 y 座標反轉, 且 offset canvas.height # (X scale, X skew, Y skew, Y scale, X offset, Y offset) # 配合圖形位置進行座標轉換 ctx.transform(1, 0, 0, -1, canvas.width/2+250, canvas.height/2+100) # 畫出 x 與 y 座標線 # 各座標值放大 3 倍 ratio = 3 ctx.moveTo(0, 0) ctx.lineTo(-30*ratio, 0) start_point = fourbar_list[0].split(\",\") ctx.moveTo(float(start_point[0])*ratio, float(start_point[1])*ratio) count = 0 for data in fourbar_list[1:]: point = data.split(\",\") #count = count + 1 #container1 <= str(count) + \":\" + point[0] + \",\" + point[1] #container1 <= html.BR() ctx.lineTo(float(point[0])*ratio, float(point[1])*ratio) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() (4)練習影片 40423245機械設計工程系 - 協同產品設計實習課程W9-fourbar link 40 點分析 from 40423245 on Vimeo . (三) Fourbar Walker OnShape 零件協同繪圖與組立查驗 (1)練習影片 40423245機械設計工程系 - 協同產品設計實習課程W9-(三) Fourbar Walker OnShape 零件協同繪圖與組立查驗 from 40423245 on Vimeo .","title":"2017/04/19 W9","tags":"Course"},{"url":"./2017spring-cd-W8.5.html","text":"一至八週報告整合 第一週連結 一. 可至 2017 Spring 協同產品設計實習 觀看這學期的課程大綱， 二. 了解如何使用stunnel 第二週連結 一. 利用python找出缺課人員 二. 在solvespace組立四連桿，並放置到Vrep裡。 第三週連結 1. 建置fossil 2. 請完成 Solvespace 30-50-60 cm 比例的四連桿組立, 並轉出 stl 檔案, 以 import 方式轉入 V-rep 3. 請利用 Onshape 完成上述相同尺寸之四連桿機構, 以 stl 轉出 (或其他格式) 後, 再轉入 V-rep 4. 請在 50 連桿上加上 50-50-50 正三角形, 以 Solvespace 輸入該三角形頂點運動軌跡 5. 請設法驗證上述四連桿運動軌跡, 是否正確, 並設法在分組網頁中執行該四連桿機構的運動模擬 第四週連結 1. Fossil新增組員以及組員權限設定 2. 在Onshape繪製單連桿機構並轉出stl檔案 3. 在solvespace繪製單連桿機構並轉出stl檔案 第五週連結 1. 如何在fossil筆記倉儲主頁顯示作業 2. 將單連桿轉入V-rep並使其作動 第六週連結 1. 利用Onshape裡的變數指令來繪製四連桿，並匯入V-rep裝上馬達。 第七週連結 1. 利用fossil對倉儲進行管理練習 2. 利用Onshape繪製八連桿 3. 將八連桿匯入V-rep並使其作動 第八週連結 1. 自評 總結： 這學期導入了fossil來跟git 一起管理倉儲，這樣在以後假如git沒支援了，還可以用fossil；這學期也加入了V-rep，可以結合上學期的Onshape以及solvespace，繪製機構以及模擬，練習的範例有單連桿、四連桿及八連桿。 心得及自評 每一週都有跟上進度，也都有進行練習以及拍影片，但在於組員的協同上還需要改進，自評75分。 影片 第一週 W1 第二週 python找出缺課人員 Solvespace四連桿組立 Onshape四連桿 任務四、任務五 第三週 建置Fossil SCM Fossil權限設定 Onshape單連桿 solvespace單連桿 Vrep單連桿 第四週 Fossil新增組員 Onshape單連桿機構 solvespace單連桿機構 回家練習 第五週 W5上課練習 W5回家練習 第六週 W6上課練習 第七週 fossil倉儲管理 Onshape八連桿 八連桿V-rep","title":"2017/04/18 W9","tags":"Course"},{"url":"./2017spring-cd-W8.html","text":"2017Spring 協同產品設計實習課程 第八週 自評 小組互評: https://pygroup-ag100.rhcloud.com 個人自評: http://mde1a2.kmol.info:8000/k96tgzh1ofbl 只要在 google上搜尋 site:edu.tw hyperworks 即可以找到放置在結尾為 edu.tw 裡有 hyperworks 的資料","title":"2017/04/12 W8","tags":"Course"},{"url":"./2017spring-cd-W7.html","text":"2017Spring 協同產品設計實習課程 第七週 一.利用fossil對倉儲進行管理練習 二.利用Onshape繪製八連桿 三.將八連桿匯入V-rep並使其作動 上課筆記 1. 利用fossil對倉儲進行管理練習 2. 利用Onshape繪製八連桿 3. 將八連桿匯入V-rep並使其作動 練習 1. 利用fossil對倉儲進行管理練習 利用以下指令對fossil倉儲進行管理 fossil clone uri foo.fossil (將遠端的倉儲下載下來) fossil open ./../../foo.fossil (將下載下來的倉儲打開) fossil add . (將改版的倉儲推至暫存區) fossil remote-url off (將自動推送改為手動，這是與git不同之處，fossil會自動推送) fossil push https://user@192.168.X.XX (將暫存區的檔案推至遠端) 2. 利用Onshape繪製八連桿 與四連桿相同利用參數指令繪製零件，並利用轉動指令及緊固指令將八連桿組立起來 零件連結 ： Onshape八連桿機構 3. 將八連桿匯入V-rep並使其作動 與四連桿相同，只不過這次加入了更多的Dummy，因此在其從屬關係上須特別小心。 心得 這禮拜加入更多的Dummy，以及在桿子上的從屬關係更加的複雜，讓我在練習上有些手無足措，也花了滿久的時間，這禮拜還加入了fossil的倉儲管理，fossil對我來說還相當新鮮，需要盡快地了解其架構。 影片 1. 利用fossil對倉儲進行管理練習 40423245機械設計工程系 - 協同產品設計實習課程W7-利用fossil對倉儲進行管理練習 from 40423245 on Vimeo . 2. 利用Onshape繪製八連桿 40423245機械設計工程系 - 協同產品設計實習課程W7-利用Onshape繪製八連桿 from 40423245 on Vimeo . 3. 將八連桿匯入V-rep並使其作動 40423245機械設計工程系 - 協同產品設計實習課程-W7-將八連桿匯入V-rep並使其作動 from 40423245 on Vimeo .","title":"2017/04/05 W7","tags":"Course"},{"url":"./2017spring-cd-W6.html","text":"2017Spring 協同產品設計實習課程 第六週 一.利用Onshape裡的變數指令來繪製四連桿，並匯入V-rep裝上馬達 上課筆記 1. 利用Onshape裡的變數指令來繪製四連桿，並匯入V-rep裝上馬達。 練習 在Onshape裡建立一個新文件，並設定好參數設定 接著繪製草圖，在標註尺寸時利用#+參數名稱加入設定好的參數，並將其擠出為零件 接著在組合件裡匯入零件，並利用 指令組立桿子，利用 指令組立軸 零件連結 ： Onshape四連桿機構 接著將組立好的四連桿轉出stl，並匯入V-rep，將各個零件分開，加入旋轉軸，加入馬達，將桿子設為動態物件後，設好從屬關係。 接著新增兩個Dummy 並設定兩個Dummy的關係Dynamics 心得 這禮拜加入了Dummy的工具，還不太熟悉需要好好的研究一下。 練習影片 40423245機械設計工程系 - 協同產品設計實習課程-W6上課練習 from 40423245 on Vimeo .","title":"2017/03/29 W6","tags":"Course"},{"url":"./2017spring-cd-W5.html","text":"2017Spring 協同產品設計實習課程 第五週 一.如何在fossil筆記倉儲主頁顯示作業 二.將單連桿轉入V-rep並使其作動 上課筆記 1. 如何在fossil筆記倉儲主頁顯示作業 2. 將單連桿轉入V-rep並使其作動 練習 1. 如何在fossil筆記倉儲主頁顯示作業 只要在wiki裡新增一個與倉儲筆記同名稱的檔案，即可在fossil筆記倉儲主頁顯示作業 在建立wiki有三種格式可選擇，wiki、Markdown及html，安全性以wiki最高，Markdown其次，html最低 2. 將單連桿轉入V-rep並使其作動 先將在繪圖軟體繪製好的單連桿利用Import/Mesh匯入V-rep 接著利用Divide selected shapes將單連桿的零件分開 利用Add/Joint/Revolute新增一個旋轉軸 將旋轉軸的位置跟繪製的軸合併再一起 設置好各零件的從屬關係 接著設定旋轉軸的角速度，並固定單連桿 接著將桿子設為動態物件 練習心得 發現V-rep是個非常強大的軟體，可以模擬真實的情況，單連桿是較為簡單的練習，因此很快就了解了狀況。 練習影片 40423245機械設計工程系 - 協同產品設計實習課程-W5上課練習 from 40423245 on Vimeo . 回家練習 跟單連桿一樣先將檔案轉入V-rep，接著將零件分開，之後加入一個旋轉軸，將旋轉軸的位置跟繪製的軸合併再一起 四個旋轉軸都設定好了之後，設定好各零件的從屬關係 加入兩個Dummy，一個放置在最後一個旋轉軸，另一個放置在第一桿子下 設定好兩者的關係 回家練習心得 四連桿相較於單連趕多了個Dummy，在它的使用上花費了不少時間。 回家練習影片 40423245機械設計工程系 - 協同產品設計實習課程-W5回家練習 from 40423245 on Vimeo .","title":"2017/03/22 W5","tags":"Course"},{"url":"./2017spring-cd-W4.html","text":"2017Spring 協同產品設計實習課程 第四週 一.Fossil新增組員以及組員權限設定 二.在Onshape繪製單連桿機構並轉出stl檔案 三.在solvespace繪製單連桿機構並轉出stl檔案 上課筆記 1. Fossil新增組員以及組員權限設定 2. 在Onshape繪製單連桿機構並轉出stl檔案 3. 在solvespace繪製單連桿機構並轉出stl檔案 練習 1. Fossil新增組員以及組員權限設定 fossil開啟後 ，到admin/user/add裡可新增筆記倉儲裡的成員 2. 在Onshape繪製單連桿機構並轉出stl檔案 繪製出所需零件 ，底座、軸及單連桿，並將其組立起來 Onshape單連桿機構 3. 在solvespace繪製單連桿機構並轉出stl檔案 繪製出所需零件 ，底座、軸及單連桿，並將其組立起來 練習心得 這禮拜所繪製的單連桿零件還蠻簡單的。 練習影片 1. Fossil新增組員以及組員權限設定 Fossil新增組員 2. 在Onshape繪製單連桿機構並轉出stl檔案 Onshape單連桿機構 3. 在solvespace繪製單連桿機構並轉出stl檔案 solvespace單連桿機構 4. 回家練習 回家練習","title":"2017/03/15 W4","tags":"Course"},{"url":"./2017spring-cd-W3.html","text":"2017Spring 協同產品設計實習課程 第三週 一. 建置fossil 二. 請完成 Solvespace 30-50-60 cm 比例的四連桿組立, 並轉出 stl 檔案, 以 import 方式轉入 V-rep 三. 請利用 Onshape 完成上述相同尺寸之四連桿機構, 以 stl 轉出 (或其他格式) 後, 再轉入 V-rep 四.請在 50 連桿上加上 50-50-50 正三角形, 以 Solvespace 輸入該三角形頂點運動軌跡 五. 請設法驗證上述四連桿運動軌跡, 是否正確, 並設法在分組網頁中執行該四連桿機構的運動模擬 第三週上課內容 從 https://mde2al.kmol.info 進入wiki檢視每周進度，並介紹了hyperworks這套軟體，包括檢測受力.受熱.流力.最小化資源利用‧‧‧，還給我們十則影片翻譯，以便了解hyperworks以及增進英文能力。 1. 建置fossil，在cmd裡進入Y\\tmp\\fossil_repo的資料夾，輸入fossil init foo .fossil的指令( foo 的位置可輸入組別名稱)，第三行有帳戶名稱與密碼需特別注意。 可至admin/user裡更改帳戶名稱及密碼 可至admin/configuration裡更改標題 第三週任務 1. 請至課程網頁中 w3 Hyperworks 處瀏覽 10 個影片, 請每組選兩個影片, 設法寫出該影片的英文逐字稿, 目的是希望能夠最佳化行走機構的零件 Hyperworks1 Hyperworks2 Hyperworks3 Hyperworks4 Hyperworks 14-1 Hyperworks 14-2 Hyperworks 14-3 Hyperworks 14-4 Hyperworks 14-5 Hyperworks 14-6 2. 請完成 Solvespace 30-50-60 cm 比例的四連桿組立, 並轉出 stl 檔案, 以 import 方式轉入 V-rep 先在solvespace裡繪製出四連桿結構 再將桿子組立起來(利用點與點的重合、線的共線及點與面的重合，限制桿子的作動。) 最後將四連桿儲存成stl檔`並用Vrep裡的import裡的Mash開啟(開啟時四連桿會重疊到地面，可用object/item shift調整Z軸高度) 3. 請利用 Onshape 完成上述相同尺寸之四連桿機構, 以 stl 轉出 (或其他格式) 後, 再轉入 V-rep 先在Onshape中繪製出四連桿 Onshape四連桿機構 接著將四連桿匯出，分別有PARASOLID，ACIS ，STEP，IGES，COLLADA，STL的檔案格式 接著在Vrep裡用import裡的Mesh將檔案匯入，發現只能匯入stl檔案 4. 請在 50 連桿上加上 50-50-50 正三角形, 以 Solvespace 輸入該三角形頂點運動軌跡 先利用solvespace在 50 連桿上加上 50-50-50 正三角形，並利用Analyze裡的Trace point繪製出頂點的運動軌跡。 5. 請設法驗證上述四連桿運動軌跡, 是否正確, 並設法在分組網頁中執行該四連桿機構的運動模擬 接著可利用Stop point 將路徑匯出成csv檔，接著可利用Excel裡的圖表繪製功能驗證軌跡是否相同。 最後利用課程網誌裡 協同產品設計實習第1週任務 的程式碼去驗證solvespace裡所繪製的運動軌跡。 結果 : cx= -65.20944533000791 cy= 29.544232590366242 dx= -22.53868820588739 dy= 55.60582284219696 ex= -66.44406598905394 ey= 79.52898738448577 心得 這學期的倉儲的wiki要在不同的地方編輯，還需要時間來適應，還有在做任務一時，明顯的發現到自己英文能力的不足，希望能盡快的補足這方面的能力 任務二影片 40423245機械設計工程系 - 協同產品設計實習課程-W3任務二完成 Solvespace 30-50-60 cm 比例的四連桿組立 from 40423245 on Vimeo . 任務三影片 40423245機械設計工程系 - 協同產品設計實習課程-W3任務三利用 Onshape 完成四連桿機構, 以 stl 轉出後, 再轉入 V-rep from 40423245 on Vimeo . 任務四、五影片 40423245機械設計工程系 - 協同產品設計實習課程-W3任務四、任務五 from 40423245 on Vimeo .","title":"2017/03/08 W3","tags":"Course"},{"url":"./2017spring-cd-W2.html","text":"2017Spring 協同產品設計實習課程 第二週 一.利用python找出缺課人員 二.在solvespace組立四連桿，並放置到Vrep裡。 一. 利用python找出缺課人員 可至班級倉儲data下載W2資料夾裡的cd_w2.py(有填寫座位表的人)和w2b_registered.txt(有修課的人)，接著利用利用程式碼列印出分組名單、座位列表、缺席學生和學生總數。 分組座位程式碼 #import os #讀取w2b_cadlab.txt的檔案將其儲存為adata，並設定encoding為utf-8 adata = open(\"w2b_cadlab.txt\", encoding=\"utf-8\").read() #讀取w2b_registered.txt的檔案將其儲存為rdata，並一行一行隔開，並設定encoding為utf-8 rdata = open(\"w2b_registered.txt\", encoding=\"utf-8\").read().splitlines() #列印出adata，以便檢查結果 #print(adata) #利用splitlines將adata一行一行隔開並其儲存為alist alist = adata.splitlines() #列印出alist[2]，以便檢查結果 #print(alist[2]) #將變數n儲存為0 n = 0 #將列從0開始算起 row = 0 #將final_list儲存為一個空的數列 final_list = [] #將w2_list儲存為一個空的數列 w2_list = [] #執行一個for迴圈從第二列開始 for stud_num in alist[2:]: #每執行完一次迴圈列數+1 row = row + 1 #執行完迴圈後用\\將其隔開並儲存為blist blist = stud_num.split(\"\\t\") #列印出blist，以便檢查結果 #print(blist) #將行從0開始算起 column = 0 #執行一個for迴圈去取得blist裡的數列 for i in range(len(blist)): #每執行完一次迴圈行數+1 column = column + 1 #假如blist數列裡不是空白 if blist[i] != \"\": #列印出blist[i]，以便檢查結果 #print(blist[i]) #將組序有用_隔開的儲存為clist clist = blist[i].split(\"_\") #將組序+_+學號+_+列+行的資料儲存為stud_data stud_data = clist[0]+\"_\"+clist[1]+\"_\"+str(row)+\"_\"+str(column) #將stud_data結果附加在final_list的資料裡 final_list.append(stud_data) #將clist[1]結果附加在w2_list的資料裡 w2_list.append(clist[1]) #每執行完一次迴圈n+1 n = n +1 # 根據數列前導字串排序, 目的在建立分組數列 group_list = sorted(final_list) #列印出分組名單 print(\"分組名單:\") #執行一個for迴圈去取得group_list裡的數列 for i in range(len(group_list)): #列印出 group_list[i]的資料 print(group_list[i]) #列印出座位列表 print(\"座位列表:\") #執行一個for迴圈去取得final_list裡的數列 for i in range(len(final_list)): #列印出 final_list[i]的資料 print(final_list[i]) #執行一個for迴圈去取得rdata裡的數列 for i in range(len(rdata)): #假如有在rdata裡但沒有在w2_list裡，目的在找出缺席學生 if rdata[i] not in w2_list: #列印出 rdata[i]的資料，缺席學生 print(\"缺席學生:\", rdata[i]) #列印出學生總數n個 print(\"學生總數:\", n) #print(os.environ) 二. 在solvespace組立四連桿，並放置到Vrep裡。 先在solvespace裡繪製出四連桿結構 再將桿子組立起來(利用點與點的重合、線的共線及點與面的重合，限制桿子的作動。) 最後將四連桿儲存成stl檔`並用Vrep裡的import裡的Mash開啟(開啟時四連桿會重疊到地面，可用object/item shift調整Z軸高度) 第二週心得 這禮拜理解到了程式碼的方便之處，體驗到了利用程式碼去處理繁雜的資料，r接著開始了解如何使用Vrep，以利之後要設計的八隻腳。 第二週心得影片 40423245機械設計工程系 - 協同產品設計實習課程-W2 from 40423245 on Vimeo .","title":"2017/03/01 W2","tags":"Course"},{"url":"./2017spring-cd-W1.html","text":"2017Spring 協同產品設計實習課程 第一週 一.可至 可至 2017 Spring 協同產品設計實習 觀看這學期的課程大綱 二.了解如何使用stunnel 三.利用python程式碼控制Vrep裡的單連桿作動 上課筆記 一. 可至 2017 Spring 協同產品設計實習 觀看這學期的課程大綱，老師介紹了Blender 3dstudio maya的相關性，簡略說明c語言與python的優劣與使用時機。 二. 了解如何使用stunnel ，並且嘗試以anonymous（無名氏/遊客）的身份進入https://192.168.1.24/2017springvcp_hw/index。 在按下start之後，會出現錯誤的圖案 (1) ，這是因為stunnel資料夾裡的config/styunnel.conf裡的ip與電腦的ip不同(styunnel.conf裡的分號代表註解)，可至cmd打ipconfig/all的指令，找到電腦的ip位置並將其複製、貼到styunnel.conf裡 (2) ，(443為https的Port號不須修改)，如果有設置proxy就必須要到設定proxy的地方按進階，將電腦ip設為額外ip，這樣就可至google打網址，並且嘗試以anonymous（無名氏/遊客）的身份進入https://192.168.1.24/2017springvcp_hw/index。 (1) (2) 三. 利用python程式碼控制Vrep裡的單連桿作動。 可至 課程倉儲 的data裡下載fourbar_eightbar_solvespace_vrep.7z以及onelink_vrep_remoteapi_pos_vel.7z兩個檔案，解壓縮後會有三個檔案，分別是單連桿、四連桿及八連桿，可試著在solvespace及Vrep裡開啟。 在Vrep裡開啟one_link_robot_remoteAPI.ttt的檔案(ttt是Vrep檔案的副檔名)，在SciTE裡開啟one_link_robot_remoteAPI_joint_target_vel.py的檔案，按下Tool裡的Go即可開始控制單連桿，按Enter會旋轉，按P會暫停。 第一週心得 在經過上學期得學習，發現這學期的課程變得有點難，在每個禮拜最後一堂課還要上台分享，期望能迅速地進入狀況。 第一週心得影片 40423245機械設計工程系-協同產品設計實習課程-W1 from 40423245 on Vimeo .","title":"2017/02/22 W1","tags":"Course"}]};